--- /core/iwasm/common/wasm_native.c
+++ /core/iwasm/common/wasm_native.c
 void *
 wasm_native_create_context_key(void (*dtor)(WASMModuleInstanceCommon *inst,
@@ -570,6 +571,11 @@ wasm_native_init()
     if (!wasm_native_register_natives("wasi_nn", native_symbols,
                                       n_native_symbols))
         goto fail;
+
+    n_native_symbols = get_wasi_ephemeral_nn_export_apis(&native_symbols);
+    if (!wasm_native_register_natives("wasi_ephemeral_nn", native_symbols,
+                                      n_native_symbols))
+        goto fail;
 #endif
 
 #if WASM_ENABLE_QUICK_AOT_ENTRY != 0
--- /core/iwasm/libraries/wasi-nn/src/utils/wasi_nn_app_native.c
+++ /core/iwasm/libraries/wasi-nn/src/utils/wasi_nn_app_native.c
@@ -70,10 +70,55 @@ graph_builder_array_app_native(wasm_module_inst_t instance,
     return success;
 }
 
+error
+graph_builder_array_app_native_ephemeral(wasm_module_inst_t instance,
+                                         graph_builder_wasm *builder_wasm,
+                                         uint32_t size,
+                                         graph_builder_array *builder_array)
+{
+    if (!wasm_runtime_validate_native_addr(instance, builder_wasm,
+                                           size * sizeof(graph_builder_wasm))) {
+        NN_ERR_PRINTF("builder_wasm is invalid");
+        return invalid_argument;
+    }
+
+    NN_DBG_PRINTF("Graph builder array contains %d elements", size);
+
+    graph_builder *builder =
+        (graph_builder *)wasm_runtime_malloc(size * sizeof(graph_builder));
+    if (builder == NULL)
+        return missing_memory;
+
+    for (uint32_t i = 0; i < size; ++i) {
+        if (!wasm_runtime_validate_app_addr(
+                instance, builder_wasm[i].buf_offset, builder_wasm[i].size)) {
+            NN_ERR_PRINTF("builder_wasm[i].buf_offset is invalid");
+            return invalid_argument;
+        }
+
+        error res;
+        if (success
+            != (res = graph_builder_app_native(instance, &builder_wasm[i],
+                                               &builder[i]))) {
+            wasm_runtime_free(builder);
+            return res;
+        }
+
+        NN_DBG_PRINTF("Graph builder %d contains %d elements", i,
+                      builder->size);
+    }
+
+    builder_array->buf = builder;
+    builder_array->size = size;
+    return success;
+}
+
 static error
 tensor_data_app_native(wasm_module_inst_t instance, uint32_t total_elements,
                        tensor_wasm *input_tensor_wasm, tensor_data *data)
 {
+    // TODO: the size should be total_elements * size of per element depending
+    // on the type
     if (!wasm_runtime_validate_app_addr(
             instance, input_tensor_wasm->data_offset, total_elements)) {
         NN_ERR_PRINTF("input_tensor_wasm->data_offset is invalid");
@@ -161,3 +206,90 @@ tensor_app_native(wasm_module_inst_t instance, tensor_wasm *input_tensor_wasm,
     input_tensor->data = data;
     return success;
 }
+
+static error
+tensor_data_app_native_ephemeral(wasm_module_inst_t instance,
+                                 uint32_t total_elements,
+                                 tensor_wasm_ephemeral *input_tensor_wasm,
+                                 tensor_data *data)
+{
+    if (!wasm_runtime_validate_app_addr(instance,
+                                        input_tensor_wasm->data_offset,
+                                        input_tensor_wasm->data_size)) {
+        NN_ERR_PRINTF("input_tensor_wasm->data_offset is invalid");
+        return invalid_argument;
+    }
+    *data = (tensor_data)wasm_runtime_addr_app_to_native(
+        instance, input_tensor_wasm->data_offset);
+    return success;
+}
+
+static error
+tensor_dimensions_app_native_ephemeral(wasm_module_inst_t instance,
+                                       tensor_wasm_ephemeral *input_tensor_wasm,
+                                       tensor_dimensions **dimensions)
+{
+    tensor_dimensions_wasm *dimensions_wasm = &input_tensor_wasm->dimensions;
+
+    if (!wasm_runtime_validate_app_addr(instance, dimensions_wasm->buf_offset,
+                                        sizeof(tensor_dimensions))) {
+        NN_ERR_PRINTF("dimensions_wasm->buf_offset is invalid");
+        return invalid_argument;
+    }
+
+    *dimensions =
+        (tensor_dimensions *)wasm_runtime_malloc(sizeof(tensor_dimensions));
+    if (dimensions == NULL)
+        return missing_memory;
+
+    (*dimensions)->size = dimensions_wasm->size;
+    (*dimensions)->buf = (uint32_t *)wasm_runtime_addr_app_to_native(
+        instance, dimensions_wasm->buf_offset);
+
+    NN_DBG_PRINTF("Number of dimensions: %d", (*dimensions)->size);
+    return success;
+}
+
+error
+tensor_app_native_ephemeral(wasm_module_inst_t instance,
+                            tensor_wasm_ephemeral *input_tensor_wasm,
+                            tensor *input_tensor)
+{
+    NN_DBG_PRINTF("Converting tensor_wasm to tensor");
+    if (!wasm_runtime_validate_native_addr(instance, input_tensor_wasm,
+                                           sizeof(tensor_wasm))) {
+        NN_ERR_PRINTF("input_tensor_wasm is invalid");
+        return invalid_argument;
+    }
+
+    error res;
+
+    tensor_dimensions *dimensions = NULL;
+    if (success
+        != (res = tensor_dimensions_app_native_ephemeral(
+                instance, input_tensor_wasm, &dimensions))) {
+        NN_ERR_PRINTF("error when parsing dimensions");
+        return res;
+    }
+
+    uint32_t total_elements = 1;
+    for (uint32_t i = 0; i < dimensions->size; ++i) {
+        total_elements *= dimensions->buf[i];
+        NN_DBG_PRINTF("Dimension %d: %d", i, dimensions->buf[i]);
+    }
+    NN_DBG_PRINTF("Tensor type: %d", input_tensor_wasm->type);
+    NN_DBG_PRINTF("Total number of elements: %d", total_elements);
+
+    tensor_data data = NULL;
+    if (success
+        != (res = tensor_data_app_native_ephemeral(instance, total_elements,
+                                                   input_tensor_wasm, &data))) {
+        wasm_runtime_free(dimensions);
+        return res;
+    }
+
+    input_tensor->type = input_tensor_wasm->type;
+    input_tensor->dimensions = dimensions;
+    input_tensor->data = data;
+    return success;
+}
--- /core/iwasm/libraries/wasi-nn/src/utils/wasi_nn_app_native.h
+++ /core/iwasm/libraries/wasi-nn/src/utils/wasi_nn_app_native.h
@@ -39,13 +39,31 @@ typedef struct {
     uint32_t data_offset;
 } tensor_wasm;
 
+typedef struct {
+    tensor_dimensions_wasm dimensions;
+    tensor_type type;
+    uint32_t data_offset;
+    uint32_t data_size;
+} tensor_wasm_ephemeral;
+
 error
 graph_builder_array_app_native(wasm_module_inst_t instance,
                                graph_builder_array_wasm *builder,
                                graph_builder_array *builder_native);
 
+error
+graph_builder_array_app_native_ephemeral(wasm_module_inst_t instance,
+                                         graph_builder_wasm *builder_wasm,
+                                         uint32_t size,
+                                         graph_builder_array *builder_array);
+
 error
 tensor_app_native(wasm_module_inst_t instance, tensor_wasm *input_tensor,
                   tensor *input_tensor_native);
 
+error
+tensor_app_native_ephemeral(wasm_module_inst_t instance,
+                            tensor_wasm_ephemeral *input_tensor_wasm,
+                            tensor *input_tensor);
+
 #endif
--- /core/iwasm/libraries/wasi-nn/src/wasi_nn.c
+++ /core/iwasm/libraries/wasi-nn/src/wasi_nn.c
 static void
 value_destroy_func(void *value)
@@ -234,6 +235,52 @@ fail:
     return res;
 }
 
+error
+wasi_ephemeral_nn_load(wasm_exec_env_t exec_env, graph_builder_wasm *builder,
+                       uint32_t builder_wasm_size, graph_encoding encoding,
+                       execution_target target, graph *g)
+{
+    NN_DBG_PRINTF("Running wasi_ephemeral_nn_load [encoding=%d, target=%d]...",
+                  encoding, target);
+
+    if (!is_encoding_implemented(encoding)) {
+        NN_ERR_PRINTF("Encoding not supported.");
+        return invalid_encoding;
+    }
+
+    wasm_module_inst_t instance = wasm_runtime_get_module_inst(exec_env);
+    bh_assert(instance);
+
+    error res;
+    graph_builder_array builder_native = { 0 };
+    if (success
+        != (res = graph_builder_array_app_native_ephemeral(
+                instance, builder, builder_wasm_size, &builder_native)))
+        return res;
+
+    if (!wasm_runtime_validate_native_addr(instance, g, sizeof(graph))) {
+        NN_ERR_PRINTF("graph is invalid");
+        res = invalid_argument;
+        goto fail;
+    }
+
+    WASINNContext *wasi_nn_ctx = wasm_runtime_get_wasi_nn_ctx(instance);
+    res = lookup[encoding].load(wasi_nn_ctx->tflite_ctx, &builder_native,
+                                encoding, target, g);
+
+    NN_DBG_PRINTF("wasi_nn_load finished with status %d [graph=%d]", res, *g);
+
+    wasi_nn_ctx->current_encoding = encoding;
+    wasi_nn_ctx->is_model_loaded = true;
+
+fail:
+    // XXX: Free intermediate structure pointers
+    if (builder_native.buf)
+        wasm_runtime_free(builder_native.buf);
+
+    return res;
+}
+
 error
 wasi_nn_init_execution_context(wasm_exec_env_t exec_env, graph g,
                                graph_execution_context *ctx)
@@ -295,6 +342,39 @@ wasi_nn_set_input(wasm_exec_env_t exec_env, graph_execution_context ctx,
     return res;
 }
 
+error
+wasi_ephemeral_nn_set_input(wasm_exec_env_t exec_env,
+                            graph_execution_context ctx, uint32_t index,
+                            tensor_wasm_ephemeral *input_tensor)
+{
+    NN_DBG_PRINTF("Running wasi_nn_set_input [ctx=%d, index=%d]...", ctx,
+                  index);
+
+    wasm_module_inst_t instance = wasm_runtime_get_module_inst(exec_env);
+    bh_assert(instance);
+    WASINNContext *wasi_nn_ctx = wasm_runtime_get_wasi_nn_ctx(instance);
+
+    error res;
+    if (success != (res = is_model_initialized(wasi_nn_ctx)))
+        return res;
+
+    tensor input_tensor_native = { 0 };
+    if (success
+        != (res = tensor_app_native_ephemeral(instance, input_tensor,
+                                              &input_tensor_native)))
+        return res;
+
+    res = lookup[wasi_nn_ctx->current_encoding].set_input(
+        wasi_nn_ctx->tflite_ctx, ctx, index, &input_tensor_native);
+
+    // XXX: Free intermediate structure pointers
+    if (input_tensor_native.dimensions)
+        wasm_runtime_free(input_tensor_native.dimensions);
+
+    NN_DBG_PRINTF("wasi_nn_set_input finished with status %d", res);
+    return res;
+}
+
 error
 wasi_nn_compute(wasm_exec_env_t exec_env, graph_execution_context ctx)
 {
@@ -343,11 +423,45 @@ wasi_nn_get_output(wasm_exec_env_t exec_env, graph_execution_context ctx,
     return res;
 }
 
+error
+wasi_ephemeral_nn_get_output(wasm_exec_env_t exec_env,
+                             graph_execution_context ctx, uint32_t index,
+                             tensor_data output_tensor,
+                             uint32_t output_tensor_len,
+                             uint32_t *output_tensor_size)
+{
+    NN_DBG_PRINTF("Running wasi_nn_get_output [ctx=%d, index=%d]...", ctx,
+                  index);
+
+    wasm_module_inst_t instance = wasm_runtime_get_module_inst(exec_env);
+    bh_assert(instance);
+    WASINNContext *wasi_nn_ctx = wasm_runtime_get_wasi_nn_ctx(instance);
+
+    error res;
+    if (success != (res = is_model_initialized(wasi_nn_ctx)))
+        return res;
+
+    if (!wasm_runtime_validate_native_addr(instance, output_tensor_size,
+                                           sizeof(uint32_t))) {
+        NN_ERR_PRINTF("output_tensor_size is invalid");
+        return invalid_argument;
+    }
+
+    res = lookup[wasi_nn_ctx->current_encoding].get_output(
+        wasi_nn_ctx->tflite_ctx, ctx, index, output_tensor, &output_tensor_len);
+    *output_tensor_size = output_tensor_len;
+    NN_DBG_PRINTF("wasi_nn_get_output finished with status %d [data_size=%d]",
+                  res, *output_tensor_size);
+    return res;
+}
+
 /* Register WASI-NN in WAMR */
 
 /* clang-format off */
 #define REG_NATIVE_FUNC(func_name, signature) \
     { #func_name, wasi_nn_##func_name, signature, NULL }
+#define REG_NATIVE_FUNC_EPHEMERAL(func_name, signature) \
+    { #func_name, wasi_ephemeral_nn_##func_name, signature, NULL }
 /* clang-format on */
 
 static NativeSymbol native_symbols_wasi_nn[] = {
@@ -358,6 +472,14 @@ static NativeSymbol native_symbols_wasi_nn[] = {
     REG_NATIVE_FUNC(get_output, "(ii**)i"),
 };
 
+static NativeSymbol native_symbols_wasi_ephemeral_nn[] = {
+    REG_NATIVE_FUNC_EPHEMERAL(load, "(*iii*)i"),
+    REG_NATIVE_FUNC(init_execution_context, "(i*)i"),
+    REG_NATIVE_FUNC_EPHEMERAL(set_input, "(ii*)i"),
+    REG_NATIVE_FUNC(compute, "(i)i"),
+    REG_NATIVE_FUNC_EPHEMERAL(get_output, "(ii*i*)i"),
+};
+
 uint32_t
 get_wasi_nn_export_apis(NativeSymbol **p_native_symbols)
 {
@@ -367,6 +489,13 @@ get_wasi_nn_export_apis(NativeSymbol **p_native_symbols)
     return sizeof(native_symbols_wasi_nn) / sizeof(NativeSymbol);
 }
 
+uint32_t
+get_wasi_ephemeral_nn_export_apis(NativeSymbol **p_native_symbols)
+{
+    *p_native_symbols = native_symbols_wasi_ephemeral_nn;
+    return sizeof(native_symbols_wasi_nn) / sizeof(NativeSymbol);
+}
+
 #if defined(WASI_NN_SHARED)
 uint32_t
 get_native_lib(char **p_module_name, NativeSymbol **p_native_symbols)
--- /core/iwasm/libraries/wasi-nn/src/wasi_nn_tensorflowlite.cpp
+++ /core/iwasm/libraries/wasi-nn/src/wasi_nn_tensorflowlite.cpp
@@ -319,9 +319,22 @@ tensorflowlite_set_input(void *tflite_ctx, graph_execution_context ctx,
         NN_DBG_PRINTF("input tensor: (scale, offset) = (%f, %f)", scale,
                       zero_point);
 
-        float *input_tensor_f = (float *)input_tensor->data;
-        for (uint32_t i = 0; i < model_tensor_size; ++i) {
-            it[i] = (uint8_t)(input_tensor_f[i] / scale + zero_point);
+        switch (input_tensor->type) {
+            case fp32:
+                for (uint32_t i = 0; i < model_tensor_size; ++i) {
+                    it[i] = (uint8_t)(((float *)input_tensor->data)[i] / scale
+                                      + zero_point);
+                }
+                break;
+            case up8:
+                // There is no need to quantize the input tensor
+                for (uint32_t i = 0; i < model_tensor_size; ++i) {
+                    it[i] = input_tensor->data[i];
+                }
+                break;
+            default:
+                NN_ERR_PRINTF("Type not supported");
+                return invalid_argument;
         }
     }
 
